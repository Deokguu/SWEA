'''
MST(최소 신장 트리)
    -양방향 그래프에서 최소한의 간선으로 모든 노드들을 연결하면서 사이클이 없는 트리
     (그 중 가중치의 합이 최소가 되는) / (노드의 수 N개일 때 N-1의 간선)

    -Prim: 정점을 기준으로 작은 가중치부터 고르자
        -우선순위큐가 사용됨
        -시간복잡도: O((V+E)logV)
        -VlogV: 보통 E가 더 크기 때문에 생랼
        -ElogV: E개의 간선을 우선순위 큐에 넣는 시간
        ->힙 트리의 높이가 최적화를 하지 않아도 logE만큼 높아지지 않는다.
        ->그만큼 시간이 빨라진다.
        결론: 간선이 많을수록 prim이 유리하다!!


    -Kruskal: 간선을 기준으로 작은 가중치부터 고르자
        -정렬이 사용됨 (간선 가중치 오름차순)
        -간선이 E개라면 시간은 O(ElogE) + 유니온파인드(사이클 검사) (경로압축 했을 때 거의 상수) => O(ElogE)
        -결론: 정점에 비해 간선이 적을수록 유리하다!!

    최단거리
    - Dijkstra -> 다익스트라로는 최단거리만 풀 수 있다. 최장거리 문제 못 푼다.
        ->더 긴 거리는 미리 확정지을 수 없다.
            -그리디로 접근하면 틀리다.
    -벨만-포드로 넘어가면 된다.


정점에 비해 간선의 수가 많으면 prim이 유리하다.
얼마나 있어야 많은걸까?

정점의 수 = v
간선의 수 = v이하 (MST까지): 간선이 적다
            완전 그래프일 때, V(V-1)/2는 간선이 매우 많다.
            V이하(MST까지)  <=   Vlog  <=    V^2
            간선이 적다        적당한 간선     간선이 많다.
        <- Kruskal 유리                     Prim 유리 ->
'''